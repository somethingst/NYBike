# 前情回顾：

1. 实现了官方的地图服务
   - 当浏览器解析到网页的<script>标签和<link>标签时，会自动发送请求，请求js和css文件。但是用户却不知道。
   - 通过AJAX请求，来实现和百度地图API的对接和地图初始化。
2. 实现了对官方数据实时数据的分析及可视化
   - 基于AJAX请求，实现对ECharts的API对接，来实现实时数据的分析。
3. 实现了对历史数据（19年4月）的分析和可视化
   - 官方数据的导入，所需数据表的生成。
   - 通过Java代码对数据库操作，再传交给前端。

# 新需求：

1. 19年4月和20年4月每日骑行数据的对比分析
   - 确定前端效果，及实现过程
   - 确定实现逻辑。
   - 将表查询之后放入之前的tb_day_count表，利用year字段来加以区分是哪年的数据。
   - 更改Service，entity，Servlet，前端页面。
   
2. 数据库
   - 声明tb_trip_2004表，将官方数据导入该表。
   - 将表查询之后放入之前的tb_day_count表，利用year字段来加以区分是哪年的数据。
   
3. 持久层：可以完全复用

4. 业务层

   - TripDayCountVO2实体类用以封装新格式对象
     - xData、yData1、yData2
     - 这里xData声明成Set类型，排除重复数据。

   - TripService类中定义新的findDayCount2方法
     - 加入了新的属性yData2，也要将它加进返回数据中
   - findDayCount2方法的测试用例
     - 测试findDayCount2方法，可以看到xData、yData1、yData2都有了数据

5. 控制层Servlet

   - 新建TripDayCountServlet2类
     - 实例化service，调用findDayCount2方法。

# 基础知识：

1. Java中的数据的容器（数据结构）
2. 基本数据结构：元素集合+关系集合，包括逻辑结构和物理结构。
   - 数组
     - `int arr[] = new int[20];`
     - 优势：数组会保存第一个元素在内存中的地址，当使用下标访问地址时，直接就是第一个元素的内存地址，当使用k下标访问第一个元素时，
     - k的内存地址 = 第一个元素内存地址 + k * 元素间的间隔
     - 劣势：
       - 数组在声明时，必须指定长度。即使数组中没有保存这些元素，开辟的内存空间也不能被其他变量使用。
       - 长度一旦声明，长度不可改变（动态数组虽然可以扩容，但是在底层是对数组的复制，造成了较大的资源浪费，尽量规避！）
       - 如果删除某一个元素，则后续元素向前移一位，如果插入某个元素，则后续的元素应该向后一移动一位。
     - 什么时候用数组？当需要频繁使用下标访问某个元素时，使用数组的访问效率非常高。
     - Java提供了一系列基本数据结构的工具类，比如ArrayList。
     - ![](https://img.99couple.top/20200608161223.jpg)
     - Array List底层基于数组的数据结构,提供了对底层数组进行CRUD的APH,开发者仅需要调用目标方法,就可以实现对底层数组的便捷操作。同时 Array List也内置了动态扩容的机制。
     - List：表示有序可重复的数据集合。（有序指的是遍历顺序和添加顺序一致，不是指定元素是按照排好序的）
       - ArrayList：底层数组结构实现，优势是基于下标访问元素效率高，劣势是在非末端的插入和删除操作效率低，存在数组动态扩容的资源消耗。
       - LinkList：底层基于双向链表结构实现，优势是非末端的插入和删除效率非常高，劣势是依据下标访问某个元素的效率非常低。
     - Set：表示无序不可重复的数据集合。（无序指的是遍历顺序不一定和添加顺序保持一致）（不重复所执行的逻辑要根据具体的实现类不同，元素重复的判断方式不同）
       - HahSet：底层基于Hash算法实现，优势添加元素的效率非常高。劣势就是无法按照元素添加顺序去存放元素，底层基于数组+链表+（红黑树）的数据结构，也涉及到动态扩容的问题。
       - TreeSet：底层基于排序二叉树实现，优势是在存入Set时已经进行了排序，遍历时的顺序是元素排序后的顺序。
       - LinkedHashSet：底层基于Hash算法实现，并且在元素之间维护了一个双向链表结构。因此，可以具备HashSet的添加 / 搜索元素效率高的优势，同时也可以按照元素的添加顺序遍历元素。
   - 链表
   - 栈
   - 树